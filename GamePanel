import javax.swing.JPanel;
import javax.swing.Timer;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Polygon;
import java.awt.BasicStroke;
import java.awt.Stroke;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.awt.geom.AffineTransform;
import java.util.List;
import java.util.ArrayList;
import java.util.Random;

class GamePanel extends JPanel implements ActionListener, KeyListener {

    // --- Game Constants ---
    private static final int PANEL_WIDTH = 800;
    private static final int PANEL_HEIGHT = 600;
    private static final int SHIP_SIZE = 20;
    private static final double SHIP_TURN_SPEED = 0.05; // radians
    private static final double SHIP_THRUST_POWER = 0.1;
    private static final double SHIP_DRAG = 0.98; // friction
    private static final int BULLET_SPEED = 7;
    private static final int BULLET_COOLDOWN = 15; // frames
    private static final int ASTEROID_INIT_COUNT = 5;
    private static final int ASTEROID_MAX_SPEED = 2;
    private static final int ASTEROID_SIZE_LARGE = 60;
    private static final int ASTEROID_SIZE_MEDIUM = 30;
    private static final int ASTEROID_SIZE_SMALL = 15;
    private static final int SCORE_LARGE_ASTEROID = 20;
    private static final int SCORE_MEDIUM_ASTEROID = 50;
    private static final int SCORE_SMALL_ASTEROID = 100;

    // --- PowerUp Constants ---
    private static final int POWERUP_SIZE = 20;
    private static final int POWERUP_DURATION = 1200; // 20s @ 60fps
    private static final int POWERUP_DROP_MIN = 5;
    private static final int POWERUP_DROP_MAX = 10;

    // --- Game State ---
    private Timer gameTimer;
    private Random random;
    private boolean inGame;
    private int score;

    // added new fields for start and pause
    private boolean started; // show start screen
    private boolean paused;  // game paused

    private List<PowerUp> powerUps;
    private int asteroidsDestroyedSinceLastPowerUp;
    private int asteroidsUntilNextPowerUp;
    private PowerUpType activePowerUp;
    private int powerUpTimeRemaining;

    // --- Ship ---
    private double shipX, shipY;
    private double shipVelX, shipVelY;
    private double shipAngle;
    private Polygon shipShape;

    // --- Input Flags ---
    private boolean rotatingLeft;
    private boolean rotatingRight;
    private boolean thrusting;
    private boolean braking;

    // --- Objects ---
    private List<Bullet> bullets;
    private List<Asteroid> asteroids;
    private int bulletCooldownTimer;

    GamePanel() {
        setPreferredSize(new java.awt.Dimension(PANEL_WIDTH, PANEL_HEIGHT));
        setBackground(Color.BLACK);
        setFocusable(true);
        addKeyListener(this);

        random = new Random();
        bullets = new ArrayList<>();
        asteroids = new ArrayList<>();
        powerUps = new ArrayList<>();

        initGame();
        gameTimer = new Timer(16, this); // ~60 FPS
        gameTimer.start();
    }

    private void initGame() {
        shipX = PANEL_WIDTH / 2.0;
        shipY = PANEL_HEIGHT / 2.0;
        shipVelX = 0;
        shipVelY = 0;
        shipAngle = -Math.PI / 2; // up

        rotatingLeft = false;
        rotatingRight = false;
        thrusting = false;
        braking = false;

        bullets.clear();
        asteroids.clear();
        powerUps.clear();

        for (int i = 0; i < ASTEROID_INIT_COUNT; i++) {
            spawnAsteroid(ASTEROID_SIZE_LARGE);
        }

        score = 0;
        inGame = true;

        // initializing start and pause
        started = false;  // show start screen
        paused = false;   // not paused
        bulletCooldownTimer = 0;

        asteroidsDestroyedSinceLastPowerUp = 0;
        asteroidsUntilNextPowerUp = POWERUP_DROP_MIN + random.nextInt(POWERUP_DROP_MAX - POWERUP_DROP_MIN + 1);
        activePowerUp = null;
        powerUpTimeRemaining = 0;

        if (gameTimer != null && !gameTimer.isRunning()) {
            gameTimer.start();
        }
    }

    private void spawnAsteroid(int size) {
        double x, y;
        double angle = random.nextDouble() * 2 * Math.PI;
        double speed = (random.nextDouble() * (ASTEROID_MAX_SPEED - 1)) + 1;

        int edge = random.nextInt(4);
        if (edge == 0) { // top
            x = random.nextDouble() * PANEL_WIDTH;
            y = -size / 2.0;
        } else if (edge == 1) { // right
            x = PANEL_WIDTH + size / 2.0;
            y = random.nextDouble() * PANEL_HEIGHT;
        } else if (edge == 2) { // bottom
            x = random.nextDouble() * PANEL_WIDTH;
            y = PANEL_HEIGHT + size / 2.0;
        } else { // left
            x = -size / 2.0;
            y = random.nextDouble() * PANEL_HEIGHT;
        }

        double dx = Math.cos(angle) * speed;
        double dy = Math.sin(angle) * speed;
        asteroids.add(new Asteroid(x, y, dx, dy, size));
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        // added start game and not paused to actions
        if (inGame && started && !paused) {
            updateGame();
        }
        repaint();
    }

    private void updateGame() {
        updateShip();
        updateBullets();
        updateAsteroids();
        updatePowerUps();
        checkCollisions();

        if (asteroids.isEmpty()) {
            spawnAsteroid(ASTEROID_SIZE_LARGE);
            spawnAsteroid(ASTEROID_SIZE_LARGE);
        }

        if (bulletCooldownTimer > 0) bulletCooldownTimer--;

        if (powerUpTimeRemaining > 0) {
            powerUpTimeRemaining--;
            if (powerUpTimeRemaining == 0) {
                activePowerUp = null;
            }
        }
    }

    private void updateShip() {
        if (rotatingLeft) shipAngle -= SHIP_TURN_SPEED;
        if (rotatingRight) shipAngle += SHIP_TURN_SPEED;

        double thrustPower = SHIP_THRUST_POWER;
        if (activePowerUp == PowerUpType.BOOSTER) {
            thrustPower *= 1.5;
        }
        if (thrusting) {
            shipVelX += Math.cos(shipAngle) * thrustPower;
            shipVelY += Math.sin(shipAngle) * thrustPower;
        }
        if (braking && activePowerUp == PowerUpType.BOOSTER) {
            shipVelX *= 0.9;
            shipVelY *= 0.9;
        }
        shipVelX *= SHIP_DRAG;
        shipVelY *= SHIP_DRAG;

        shipX += shipVelX;
        shipY += shipVelY;

        wrapCoordinates(shipX, shipY, newCoords -> {
            shipX = newCoords[0];
            shipY = newCoords[1];
        });
    }

    private void updateBullets() {
        for (int i = bullets.size() - 1; i >= 0; i--) {
            Bullet b = bullets.get(i);
            b.move();
            if (b.x < 0 || b.x > PANEL_WIDTH || b.y < 0 || b.y > PANEL_HEIGHT) {
                bullets.remove(i);
            }
        }
    }

    private void updateAsteroids() {
        for (Asteroid a : asteroids) {
            a.move();
            wrapCoordinates(a.x, a.y, newCoords -> {
                a.x = newCoords[0];
                a.y = newCoords[1];
            });
        }
    }

    private void updatePowerUps() {
        for (int i = powerUps.size() - 1; i >= 0; i--) {
            PowerUp p = powerUps.get(i);
            p.update();
            double dist = Math.sqrt(Math.pow(shipX - p.x, 2) + Math.pow(shipY - p.y, 2));
            if (dist < (SHIP_SIZE + POWERUP_SIZE) / 2.0) {
                activePowerUp = p.type;
                powerUpTimeRemaining = POWERUP_DURATION;
                powerUps.remove(i);
            }
        }
    }

    @FunctionalInterface
    private interface CoordinateWrapper { void apply(double[] newCoords); }

    private void wrapCoordinates(double x, double y, CoordinateWrapper wrapper) {
        if (x < 0) x = PANEL_WIDTH; else if (x > PANEL_WIDTH) x = 0;
        if (y < 0) y = PANEL_HEIGHT; else if (y > PANEL_HEIGHT) y = 0;
        wrapper.apply(new double[]{x, y});
    }

    private void fireBullet() {
        int cooldown = BULLET_COOLDOWN;
        if (activePowerUp == PowerUpType.RAPID_FIRE) {
            cooldown = (int) (BULLET_COOLDOWN / 1.5);
        }
        if (bulletCooldownTimer <= 0) {
            double dx = Math.cos(shipAngle) * BULLET_SPEED;
            double dy = Math.sin(shipAngle) * BULLET_SPEED;
            if (activePowerUp == PowerUpType.DOUBLE_SHOT) {
                double offsetAngle = Math.PI / 16;
                double leftAngle = shipAngle - offsetAngle;
                double rightAngle = shipAngle + offsetAngle;
                bullets.add(new Bullet(shipX, shipY, Math.cos(leftAngle) * BULLET_SPEED, Math.sin(leftAngle) * BULLET_SPEED));
                bullets.add(new Bullet(shipX, shipY, Math.cos(rightAngle) * BULLET_SPEED, Math.sin(rightAngle) * BULLET_SPEED));
            } else {
                bullets.add(new Bullet(shipX, shipY, dx, dy));
            }
            bulletCooldownTimer = cooldown;
        }
    }

    private void checkCollisions() {
        for (int i = bullets.size() - 1; i >= 0; i--) {
            Bullet b = bullets.get(i);
            for (int j = asteroids.size() - 1; j >= 0; j--) {
                Asteroid a = asteroids.get(j);
                double dist = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
                if (dist < a.size / 2.0) {
                    bullets.remove(i);
                    splitAsteroid(j);
                    break;
                }
            }
        }
        for (int i = asteroids.size() - 1; i >= 0; i--) {
            Asteroid a = asteroids.get(i);
            double dist = Math.sqrt(Math.pow(shipX - a.x, 2) + Math.pow(shipY - a.y, 2));
            if (dist < (a.size / 2.0) + (SHIP_SIZE / 2.0)) {
                inGame = false;
                gameTimer.stop();
                break;
            }
        }
    }

    private void splitAsteroid(int asteroidIndex) {
        Asteroid a = asteroids.remove(asteroidIndex);
        if (a.size == ASTEROID_SIZE_LARGE) {
            score += SCORE_LARGE_ASTEROID;
            asteroids.add(new Asteroid(a.x, a.y, random.nextDouble() * 2 - 1, random.nextDouble() * 2 - 1, ASTEROID_SIZE_MEDIUM));
            asteroids.add(new Asteroid(a.x, a.y, random.nextDouble() * 2 - 1, random.nextDouble() * 2 - 1, ASTEROID_SIZE_MEDIUM));
        } else if (a.size == ASTEROID_SIZE_MEDIUM) {
            score += SCORE_MEDIUM_ASTEROID;
            asteroids.add(new Asteroid(a.x, a.y, random.nextDouble() * 2 - 1, random.nextDouble() * 2 - 1, ASTEROID_SIZE_SMALL));
            asteroids.add(new Asteroid(a.x, a.y, random.nextDouble() * 2 - 1, random.nextDouble() * 2 - 1, ASTEROID_SIZE_SMALL));
        } else {
            score += SCORE_SMALL_ASTEROID;
        }
        asteroidsDestroyedSinceLastPowerUp++;
        if (asteroidsDestroyedSinceLastPowerUp >= asteroidsUntilNextPowerUp) {
            PowerUpType[] types = PowerUpType.values();
            PowerUpType randomType = types[random.nextInt(types.length)];
            powerUps.add(new PowerUp(a.x, a.y, randomType));
            asteroidsDestroyedSinceLastPowerUp = 0;
            asteroidsUntilNextPowerUp = POWERUP_DROP_MIN + random.nextInt(POWERUP_DROP_MAX - POWERUP_DROP_MIN + 1);
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Start screen is displayed when starting
        if (!started) {drawStartScreen(g2d);}

        else if (inGame) {
            // Main game components
            drawAimBeam(g2d);
            drawShip(g2d);
            drawBullets(g2d);
            drawAsteroids(g2d);
            drawPowerUps(g2d);
            drawScore(g2d);
            drawActivePowerUp(g2d);

            // Pause screen is displayed when paused
            if (paused) {drawPausedOverlay(g2d);}
            // Game over screen is displayed
        } else {drawGameOver(g2d);
        }
    }

    // new method for start screen added instructions for user
    private void drawStartScreen(Graphics2D g2d) {

        // Strings to be displayed
        String title = "Space Invaders";
        String msg = "Press ENTER to Start";
        String controls = "Arrows: Move  |  SPACE: Shoot  |  P: Pause  |  R: Restart";

        g2d.setColor(Color.WHITE);

        // Matched font style with draw game over
        Font largeFont = new Font("Monospaced", Font.BOLD, 75);
        Font mediumFont = new Font("Monospaced", Font.PLAIN, 30);
        Font smallFont = new Font("Monospaced", Font.PLAIN, 16);

        FontMetrics metricsLarge = g2d.getFontMetrics(largeFont);
        FontMetrics metricsMedium = g2d.getFontMetrics(mediumFont);
        FontMetrics metricsSmall = g2d.getFontMetrics(smallFont);

        // Draw title
        g2d.setFont(largeFont);
        g2d.drawString(title, (PANEL_WIDTH - metricsLarge.stringWidth(title)) / 2, PANEL_HEIGHT / 2 - 40);

        // Draw "Press ENTER to Start"
        g2d.setFont(mediumFont);
        g2d.drawString(msg, (PANEL_WIDTH - metricsMedium.stringWidth(msg)) / 2, PANEL_HEIGHT / 2 + 10);

        // Draw controls text
        g2d.setFont(smallFont);
        g2d.drawString(controls, (PANEL_WIDTH - metricsSmall.stringWidth(controls)) / 2, PANEL_HEIGHT / 2 + 50);
    }

    private void drawAimBeam(Graphics2D g2d) {
        if (activePowerUp == PowerUpType.AIM_BEAM) {
            g2d.setColor(Color.GREEN);
            Stroke dashed = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5}, 0);
            g2d.setStroke(dashed);
            double endX = shipX + Math.cos(shipAngle) * 1000;
            double endY = shipY + Math.sin(shipAngle) * 1000;
            g2d.drawLine((int) shipX, (int) shipY, (int) endX, (int) endY);
            g2d.setStroke(new BasicStroke());
        }
    }

    private void drawShip(Graphics2D g2d) {
        shipShape = new Polygon();
        shipShape.addPoint(SHIP_SIZE / 2, 0);
        shipShape.addPoint(-SHIP_SIZE / 2, -SHIP_SIZE / 3);
        shipShape.addPoint(-SHIP_SIZE / 2, SHIP_SIZE / 3);
        AffineTransform oldTransform = g2d.getTransform();
        g2d.translate(shipX, shipY);
        g2d.rotate(shipAngle);
        if (thrusting) {
            g2d.setColor(Color.ORANGE);
            g2d.fillPolygon(
                    new int[]{-SHIP_SIZE / 2, -SHIP_SIZE, -SHIP_SIZE / 2},
                    new int[]{-SHIP_SIZE / 4, 0, SHIP_SIZE / 4},
                    3
            );
        }
        g2d.setColor(Color.CYAN);
        g2d.draw(shipShape);
        g2d.setTransform(oldTransform);
    }

    private void drawBullets(Graphics2D g2d) {
        g2d.setColor(Color.YELLOW);
        for (Bullet b : bullets) {
            g2d.fillOval((int) b.x - 2, (int) b.y - 2, 4, 4);
        }
    }

    private void drawAsteroids(Graphics2D g2d) {
        g2d.setColor(Color.GRAY);
        for (Asteroid a : asteroids) {
            g2d.drawOval(
                    (int) (a.x - a.size / 2.0),
                    (int) (a.y - a.size / 2.0),
                    a.size,
                    a.size
            );
        }
    }

    private void drawPowerUps(Graphics2D g2d) {
        for (PowerUp p : powerUps) {
            Color color;
            String label;
            switch (p.type) {
                case AIM_BEAM: color = Color.GREEN; label = "A"; break;
                case DOUBLE_SHOT: color = Color.BLUE; label = "D"; break;
                case BOOSTER: color = Color.ORANGE; label = "B"; break;
                case RAPID_FIRE: color = Color.RED; label = "R"; break;
                default: color = Color.WHITE; label = "?";
            }
            g2d.setColor(color);
            g2d.fillRect(
                    (int) (p.x - POWERUP_SIZE / 2),
                    (int) (p.y - POWERUP_SIZE / 2),
                    POWERUP_SIZE,
                    POWERUP_SIZE
            );
            g2d.setColor(Color.BLACK);
            g2d.drawString(label, (int) p.x - 4, (int) p.y + 5);
        }
    }

    private void drawScore(Graphics2D g2d) {
        g2d.setColor(Color.WHITE);
        g2d.setFont(new Font("Monospaced", Font.BOLD, 20));
        g2d.drawString("Score: " + score, 10, 25);

        // Added option to pause or restart in top corner of game
        String controls = "P: Pause | R: Restart";
        FontMetrics fm = g2d.getFontMetrics();
        int textWidth = fm.stringWidth(controls);
        g2d.drawString(controls, PANEL_WIDTH - textWidth - 10, 25);
    }

    private void drawActivePowerUp(Graphics2D g2d) {
        if (activePowerUp != null && powerUpTimeRemaining > 0) {
            g2d.setColor(Color.WHITE);
            g2d.setFont(new Font("Monospaced", Font.PLAIN, 16));
            String name;
            switch (activePowerUp) {
                case AIM_BEAM: name = "AIM BEAM"; break;
                case DOUBLE_SHOT: name = "DOUBLE SHOT"; break;
                case BOOSTER: name = "BOOSTER"; break;
                case RAPID_FIRE: name = "RAPID FIRE"; break;
                default: name = ""; break;
            }
            int timeLeft = powerUpTimeRemaining / 60;
            g2d.drawString("PowerUp: " + name + " (" + timeLeft + "s)", 10, 50);
        }
    }

    // Creating overlay for pause screen
    private void drawPausedOverlay(Graphics2D g2d) {
        // Creating pause string to display
        String msg = "PAUSED";
        Font font = new Font("Monospaced", Font.BOLD, 40);
        FontMetrics m = g2d.getFontMetrics(font);

        // Dimming the screen for transparent overlay effect
        g2d.setColor(new Color(0, 0, 0, 150));
        g2d.fillRect(0, 0, PANEL_WIDTH, PANEL_HEIGHT);

        // Pause is displayed centered on screen
        g2d.setColor(Color.YELLOW);
        g2d.setFont(font);
        g2d.drawString(msg, (PANEL_WIDTH - m.stringWidth(msg)) / 2, PANEL_HEIGHT / 2);
    }

    private void drawGameOver(Graphics2D g2d) {

        // Display strings
        String msg = "Game Over";
        String scoreMsg = "Final Score: " + score;
        String restartMsg = "Press 'R' to Restart";

        // Added option to quit game once game is over
        String quitMsg = "Press 'Q' to Quit";

        Font largeFont = new Font("Monospaced", Font.BOLD, 75);
        Font mediumFont = new Font("Monospaced", Font.BOLD, 30);
        FontMetrics metricsLarge = g2d.getFontMetrics(largeFont);
        FontMetrics metricsMedium = g2d.getFontMetrics(mediumFont);
        g2d.setColor(Color.RED);
        g2d.setFont(largeFont);
        g2d.drawString(msg, (PANEL_WIDTH - metricsLarge.stringWidth(msg)) / 2, PANEL_HEIGHT / 2 - 50);g2d.setColor(Color.WHITE);g2d.setFont(mediumFont);
        g2d.drawString(scoreMsg, (PANEL_WIDTH - metricsMedium.stringWidth(scoreMsg)) / 2, PANEL_HEIGHT / 2 + 20);
        g2d.drawString(restartMsg, (PANEL_WIDTH - metricsMedium.stringWidth(restartMsg)) / 2, PANEL_HEIGHT / 2 + 60);

        // Added quit game option to be displayed in game over screen
        g2d.drawString(quitMsg, (PANEL_WIDTH - metricsMedium.stringWidth(quitMsg))    / 2, PANEL_HEIGHT / 2 + 100);
    }

    @Override
    public void keyPressed(KeyEvent e) {
        int key = e.getKeyCode();

        // Makes sure user has started the game
        if (!started) {
            // Once started the game begins
            if (key == KeyEvent.VK_ENTER) {started = true;}return;}

        // Makes it able to restart from any point in the game
        if (key == KeyEvent.VK_R) {initGame();return;}

        // Exits the game when Q is pressed
        if (key == KeyEvent.VK_Q) { System.exit(0); }

        // Pause or unpause the game
        if (key == KeyEvent.VK_P && inGame) {paused = !paused;return;}
        if (!inGame || paused) {return;}

        if (key == KeyEvent.VK_LEFT)  rotatingLeft = true;
        if (key == KeyEvent.VK_RIGHT) rotatingRight = true;
        if (key == KeyEvent.VK_UP)    thrusting = true;
        if (key == KeyEvent.VK_DOWN)  braking = true;
        if (key == KeyEvent.VK_SPACE) fireBullet();
    }

    @Override
    public void keyReleased(KeyEvent e) {
        // Makes sure user is currently playing the game
        if (!inGame || !started || paused) return;

        int key = e.getKeyCode();
        if (key == KeyEvent.VK_LEFT)  rotatingLeft = false;
        if (key == KeyEvent.VK_RIGHT) rotatingRight = false;
        if (key == KeyEvent.VK_UP)    thrusting = false;
        if (key == KeyEvent.VK_DOWN)  braking = false;
    }

    @Override
    public void keyTyped(KeyEvent e) {}
}
